import json
import logging
import uuid
from datetime import datetime, timezone

import mock

from exodus_gw import models, worker

NOW_UTC = datetime.now(timezone.utc)


def _task():
    return models.Task(
        id="8d8a4692-c89b-4b57-840f-b3f0166148d2",
        state="NOT_STARTED",
    )


@mock.patch("exodus_gw.worker.deploy.CurrentMessage.get_current_message")
@mock.patch("exodus_gw.worker.deploy.DynamoDB.batch_write")
def test_deploy_config(
    mock_batch_write, mock_get_message, db, fake_config, caplog
):
    caplog.set_level(logging.DEBUG, logger="exodus-gw")

    # Construct task that would be generated by caller.
    t = _task()

    # Construct dramatiq message that would be generated by caller.
    mock_get_message.return_value = mock.MagicMock(message_id=t.id)

    # Simulate successful write by batch_write.
    mock_batch_write.return_value = {"UnprocessedItems": {}}

    db.add(t)
    db.commit()

    worker.deploy_config(fake_config, "test", NOW_UTC)

    # It should've created an appropriate put request.
    request = {
        "my-config": [
            {
                "PutRequest": {
                    "Item": {
                        "from_date": {"S": NOW_UTC},
                        "config_id": {"S": "exodus-config"},
                        "config": {"S": json.dumps(fake_config)},
                    }
                }
            },
        ]
    }

    # It should've set task state to IN_PROGRESS.
    db.refresh(t)
    assert t.state == "IN_PROGRESS"

    assert "Task %s writing config from %s" % (t.id, NOW_UTC) in caplog.text

    # It should've called batch_write with the expected request.
    mock_batch_write.assert_called_with(mock.ANY, request)

    # It should've sent task id to complete_deploy_config_task.
    messages = db.query(models.DramatiqMessage).all()

    assert len(messages) == 1

    msg = messages[0]
    body = msg.body

    assert (
        "Sent task %s for completion via message %s" % (t.id, msg.id)
        in caplog.text
    )

    # It should've sent message with this actor & kwargs.
    assert msg.actor == "complete_deploy_config_task"
    assert body["kwargs"]["task_id"] == str(t.id)

    # And actor call should have been delayed by this long.
    delay = body["options"]["eta"] - body["message_timestamp"]
    assert abs(delay - 120000) < 1000


@mock.patch("exodus_gw.worker.deploy.CurrentMessage.get_current_message")
@mock.patch("exodus_gw.worker.deploy.DynamoDB.batch_write")
def test_deploy_config_exception(
    mock_batch_write, mock_get_message, db, fake_config, caplog
):
    caplog.set_level(logging.INFO, logger="exodus-gw")

    # Construct task that would be generated by caller.
    t = _task()

    # Construct dramatiq message that would be generated by caller.
    mock_get_message.return_value = mock.MagicMock(message_id=t.id)

    # Simulate failed batch_write.
    mock_batch_write.side_effect = RuntimeError()

    db.add(t)
    db.commit()

    worker.deploy_config(fake_config, "test", NOW_UTC)

    # It should've set task state to FAILED.
    db.refresh(t)
    assert t.state == "FAILED"

    assert "Task %s writing config from %s" % (t.id, NOW_UTC) in caplog.text
    assert "Task %s encountered an error" % t.id in caplog.text


@mock.patch("exodus_gw.worker.deploy.CurrentMessage.get_current_message")
@mock.patch("exodus_gw.worker.deploy.DynamoDB.batch_write")
def test_deploy_config_bad_state(
    mock_batch_write, mock_get_message, db, fake_config, caplog
):
    # Construct task that would be generated by caller.
    t = _task()

    # Construct dramatiq message that would be generated by caller.
    mock_get_message.return_value = mock.MagicMock(message_id=t.id)

    db.add(t)
    # Simulate prior completion of task.
    t.state = "COMPLETE"
    db.commit()

    worker.deploy_config(fake_config, "test", NOW_UTC)

    # It shouldn't have called batch_write.
    mock_batch_write.assert_not_called()

    # It should've logged a warning message.
    assert "Task %s in unexpected state, 'COMPLETE'" % t.id in caplog.text


def test_complete_deploy_config_task(db, caplog):
    caplog.set_level(logging.INFO, logger="exodus-gw")

    # Construct task that would be generated by caller.
    t = _task()
    t.state = "IN_PROGRESS"

    db.add(t)
    db.commit()

    worker.deploy.complete_deploy_config_task(t.id)

    # It should've set task state to COMPLETE.
    db.refresh(t)
    assert t.state == "COMPLETE"


def test_complete_deploy_config_task_bad_state(db, caplog):
    caplog.set_level(logging.INFO, logger="exodus-gw")

    # Simulate direct call which leaves state as NOT_STARTED.
    t = _task()

    db.add(t)
    db.commit()

    worker.deploy.complete_deploy_config_task(t.id)

    # It should've logged a warning message.
    assert "Task %s in unexpected state, 'NOT_STARTED'" % t.id in caplog.text

    # It shouldn't alter the task's state.
    db.refresh(t)
    assert t.state == "NOT_STARTED"
